How we can change the hostname
==============================
goto root user-----> sudo -i
then after we can execute the command-----> hostname <name-of-the-host> && bash



https://raw.githubusercontent.com/vsaini44/KubernetesRepo/master/Docker-kuber1.21
===================================================================================
# by using the above link we can get the script place it in a file then after execute that file
# for example the file name is ---->a 
# so here we can execute that file by using the command------> bash a  (or) ./a.sh
# after successful execution we can get the {-- 1 token --} in the master machine we can copy that token and execute over the Node machines

# script we have to execute
============================
#!/bin/bash 
sudo apt update

sudo apt install apt-transport-https ca-certificates curl software-properties-common  -y
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
sudo apt update
apt-cache policy docker-ce -y
sudo apt install docker-ce -y
wget -q -O - https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
echo deb http://apt.kubernetes.io/ kubernetes-xenial main | sudo tee /etc/apt/sources.list.d/kubernetes.list
apt update
apt install kubelet=1.21.1-00 kubeadm=1.21.1-00 kubectl=1.21.1-00 -y
sysctl net.bridge.bridge-nf-call-iptables=1

#on master
#kubeadm init --pod-network-cidr=10.244.0.0/16 >> cluster_initialized.txt
kubeadm init --pod-network-cidr=192.168.0.0/16 >> cluster_initialized.txt
mkdir /root/.kube
cp /etc/kubernetes/admin.conf /root/.kube/config
kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
#kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
systemctl restart kubelet.service
kubeadm token create --print-join-command



# Script we have to execute in the Node machines
=================================================

#!/bin/bash 
sudo apt update

sudo apt install apt-transport-https ca-certificates curl software-properties-common  -y
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
sudo apt update
apt-cache policy docker-ce -y
sudo apt install docker-ce -y
wget -q -O - https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
echo deb http://apt.kubernetes.io/ kubernetes-xenial main | sudo tee /etc/apt/sources.list.d/kubernetes.list
apt update
apt install kubelet=1.21.1-00 kubeadm=1.21.1-00 kubectl=1.21.1-00 -y
sysctl net.bridge.bridge-nf-call-iptables=1

=================================================================================
or else we can execute the commands one by one

to get libraries
=================
kubectl completion bash >> /tmp/abc
source  /temp/abc
kubectl <press tab two-times>

the bellow commands will say which paramiter we have to use in perticular yml file
====================================================================================
kubectl explain pod
kubectl explain service
kubectl explain repicaset
kubectl explain replicationcontroller
kubectl  explain deployment

Command to show the labels
==========================
kubectl get pods --show-labels

 Commandto set a label to the perticular pod
========================================
kubectl label pod <pod-name> env=<label-name>
EX:- kubectl label pod pod1 env=dev1

if you want to override the env by using the bellow command
==============================================================
kubectl label pod pod1 env=prod --override


kubectl create -f pod.yaml
kubectl get pods
vim pod.yaml
 
kubectl get pods
kubectl get pods  --show-label
kubectl get pods  --show-labels
kubectl label pod pod1 env=dev
kubectl label pod pod2 env=prod
kubectl get pods  --show-labels
vim pod.yaml
kubectl create -f pod.yaml
kubectl get pods  --show-labels
kubectl get pods -l env=prod

kubectl run image
kubectl run image --help
cat pod.yaml
kubectl get pods --show-labels
kubectl label pod pod1 dc=mumbai
kubectl get pods --show-labels
kubectl label pod pod1 env=prod
kubectl label pod pod1 env=prod --overwrite
kubectl get pods --show-labels
kubectl describe pod pod1 | less
kubectl annotate pod pod1 description="test pod for testing"
kubectl describe pod pod1 | less
kubectl get ns
kubectl create ns test-project1
kubectl get ns | grep test-project

How do create the NameSpace 
============================
if you execute the command---> kubectl get ns
it will redirected to the default namespace
if we want to see in which namespace pointing by default by using the command
--> kubectl config view
           (or)
--> kubectl config view --minify           

so that by default the pods are created inside default namespace. here if we don't want to create the pods inside the default
namespace we can create our own namespace by using the bellow command
--> kubectl create ns/namespace <namespace-Name>
ex:-->  kubectl create ns flipkartapp
after that we if can see is any pods are created in the flipkartapp namespace by using the command
-->kubectl get all -n filpkartapp
so if want execute the flipkartapp is the default namespace you can execute bellow command
Syntax:--> kubectl config set-context --current --namespace=<give name of namespace>
Ex:--> kubectl config set-context --current --namespace=flipkartapp

So now if we want to see in which namespace pointing by default by using the command
--> kubectl config view
-->kubectl get all

so again if you want to set namespace as default, execute the bellow command
Ex:--> kubectl config set-context --current --namespace=default
   --> kubectl get all
   

Example:- Pod manifast YAML file and the file name is javawebapppod.yaml
=========================================================================
apiVersion: v1
kind: Pod
metadata:
  name: javawebapppod
  labels:
    app: javawebapp
  namespace: flipkartapp
spec:
  containers:
  - name: javawebappcontainer
    image: dockerhandson/java-web-app
    ports:
    - containerPort: 8080
   
now if we check if any pods are running in the flipcartapp namespace or not by using the bellow command
--> kubectl get pod -n flipkartapp
then after we can execute the bellow command
--> kubectl apply -f javawebapppod.yaml
now the pods are created at flipkartapp namespace 

so that if we want to see in which namespace which pods are running at a time by using the command
--> kubectl get all --all-namespaces

what is the diff between Docker service and K8S service?
========================================================
here using docker service in docker-swarm we can deploye the containers/multiple (or) single replicas,and docker will manage those containers.
and comming to the K8S service, K8S service is responsible for making our pods accessable in side the network(cluster) or Exposing them to the internet
:-) we can use the K8S service to access the application's which are running inside the pod with in the cluster (or)outside the cluster

note: here Service can identify the pods by using labels and selector

=> here service can be classified into three types
   --> ClusterIp:- if we create the service using ClusterIp we can access the pod with in the cluster
   --> NodePort
   --> LoadBalancer
   what is the nodeport range in the K8S?
   =======================================
   nodeport range is 30000 to 32767
   
   Example for service YAML file name is javawebappservice.yaml
   ============================================================
   apiVersion: v1
   kind: Service
   metadata:
     name: javawebappservice
     namespace: flipkartapp
   spec:
     type: NodePort
     selector:
       app: javawebapp
     ports:
     - port: 80
       targetPort: 8080
       nodeport: 30033
       
 Note: if we won't give nodeport also K8S will randamly genarate the nodeport
 
 --> kubectl apply -f javawebappservice.yml 
 

#ReplicationController Manifest Syntax
=======================================
apiVersion: v1
kind: ReplicationController
matadata:
   name: <RC-name>
   namespace: <namespace-name>
spec:
  replicas: <no-of-pod-replicas>
  selector:
    <key>: <value>   # POD label key & value should be defind here
  template:          # Pod template(define Pod information)
    metadata:
      name: <POD name>
      labels:
        <key>: <value>   # Labels of pod
    spec:
      containers:
      - name: <name-of-the-container>
        image: <image-name>
        ports:
        - containerPort: <containerPort>
        
Example for RC and name of the RC is javawebapp_rc.yaml
========================================================
apiVersion: v1
kind: ReplicationController
matadata:
   name: javawebapprc
   namespace: flipkartapp
spec:
  replicas: 2
  selector:
    app: javawebapp   # POD label key & value should be defind here
  template:          # Pod template(define Pod information)
    metadata:
      name: javawebapppod
      labels:
        app: javawebapp   # Labels of pod
    spec:
      containers:
      - name: javawebappcontainer
        image: dockerhandson/java-web-app
        ports:
        - containerPort: 8080


 what is the diff b/w ReplicaSet and ReplicationController?
 ============================================================
  ReplicationController it will manage the pod lifecycle, we can scaleUp & scaleDown the pods and ReplicaSet also does same thing
  the only difference in selector support ReplicationController supports only Equality based selector and Replicaset supports Equality based
  as well as set based selectors. 
  Example Syntaxes:
  =================
  # RC Equality based selector
  spec:
    selector:
      <key>: <value>
      
   #RS
   spec:
     selector:                  # Equlity Based selector
       matchLabels:
         <key>: <value>
         
  #RS
  spec:
    selector:
      matchExpression:
      - key: <labelkey>
        operator: in
        values:
        - <valueOne>
           <valueTwo>
